{"version":3,"file":"static/js/451.6dc4c03a.chunk.js","mappings":"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","sources":["logic/bitlogic/BitVector.ts","logic/bitlogic/LogicalExpression.ts","logic/bitlogic/BitLogic.ts","logic/booleanlogic/BooleanExpression.ts","tooltips/worker/Worker.ts","tooltips/worker/Utils.ts","tooltips/worker/Algorithms.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["const ONE = BigInt(1);\nconst ZERO = BigInt(0);\n\nfunction intersection<T>(a: Set<T>, b: Set<T>): Set<T> {\n    if (a.size > b.size) {\n        const tmp = a;\n        // eslint-disable-next-line no-param-reassign\n        a = b;\n        // eslint-disable-next-line no-param-reassign\n        b = tmp;\n    }\n    return new Set([...a].filter((v) => b.has(v)));\n}\n\nfunction union<T>(a: Set<T>, b: Set<T>): Set<T> {\n    return new Set([...a, ...b]);\n}\n\n/**\n * A fixed-size bit vector.\n */\nexport class BitVector {\n    data: bigint;\n    intSet: Set<number>;\n\n    constructor();\n    constructor(bits: bigint, intSet: Set<number>);\n\n    constructor(bits?: bigint, intSet?: Set<number>) {\n        this.data = bits ?? ZERO;\n        this.intSet = intSet ?? new Set();\n    }\n\n    /** Sets the bit `bit` in this BitVector, if not already set. */\n    setBit(bit: number): this {\n        this.data |= ONE << BigInt(bit);\n        this.intSet.add(bit);\n        return this;\n    }\n\n    /** Clears the bit `bit` in this BitVector, if set. */\n    clearBit(bit: number): this {\n        if (this.intSet.has(bit)) {\n            this.data = this.data - (ONE << BigInt(bit));\n            this.intSet.delete(bit);\n        }\n        return this;\n    }\n\n    /** Creates a new BitVector consisting of the bits that are both in `this` and `other`. */\n    and(other: BitVector) {\n        return new BitVector(other.data & this.data, intersection(other.intSet, this.intSet));\n    }\n\n    /** Creates a new BitVector consisting of the bits that are in `this` or in `other`. */\n    or(other: BitVector) {\n        return new BitVector(other.data | this.data, union(other.intSet, this.intSet));\n    }\n\n    /** Returns true iff `bit` is set in this BitVector. */\n    test(bit: number) {\n        return this.intSet.has(bit);\n    }\n\n    /** Returns true iff all the bits in `this` are also set in `other`. */\n    isSubsetOf(other: BitVector) {\n        return this.numSetBits <= other.numSetBits && (this.data | other.data) === other.data;\n    }\n\n    /** Returns true iff all the bits in `this` are also set in `other` and the other way around. */\n    equals(other: BitVector) {\n        return this.data === other.data;\n    }\n\n    /**\n     * slow\n     */\n    toString(domainSize: number) {\n        let str = \"\";\n        for (let bit = domainSize - 1; bit >= 0; bit--) {\n            if (this.data & (ONE << BigInt(bit))) {\n                str += '1';\n            } else {\n                str += '0';\n            }\n        }\n        return str;\n    }\n\n    /** Returns a new BitVector with exactly the same bits set. */\n    clone() {\n        return new BitVector(this.data, new Set(this.intSet));\n    }\n\n    /** Returns true iff no bits are set. */\n    isEmpty() {\n        return this.numSetBits === 0;\n    }\n\n    /** Returns true iff there is a bit that's set in both `this` and `other`. */\n    intersects(other: BitVector) {\n        return Boolean(this.data & other.data);\n    }\n\n    /** Iterates over all set bits in this BitVector. */\n    iter(): IterableIterator<number> {\n        return this.intSet.values()\n    }\n\n    /** Assuming that this vector has a single set bit, returns it. */\n    getSingleSetBit(): number {\n        return this.intSet.values().next().value as number\n    }\n\n    /** Returns the number of bits set in this BitVector. */\n    get numSetBits() {\n        return this.intSet.size\n    }\n}","import { BitVector } from './BitVector';\n\n/**\n * A logical expression in DNF (disjunctive normal form).\n */\nexport class LogicalExpression {\n    conjunctions: BitVector[];\n\n    /** Creates an expression that always evaluates to false. */\n    static false() {\n        return new LogicalExpression([]);\n    }\n\n    /** Creates an expression that always evaluates to true. */\n    static true() {\n        return new LogicalExpression([new BitVector()]);\n    }\n\n    /** Constructs an expression from the given BitVectors describing a DNF expression. */\n    constructor(conjs: BitVector[]) {\n        this.conjunctions = conjs;\n    }\n\n    /**\n     * Constructs an expression that evaluates to true if `this`\n     * evaluates to true or `other` evaluates to true.\n     */\n    or(other: LogicalExpression | BitVector) {\n        if (other instanceof BitVector) {\n            return new LogicalExpression([...this.conjunctions, other]);\n        } else {\n            return new LogicalExpression([\n                ...this.conjunctions,\n                ...other.conjunctions,\n            ]);\n        }\n    }\n\n    /**\n     * Constructs an expression that evaluates to true if `this`\n     * evaluates to true and `other` evaluates to true.\n     */\n    and(other: LogicalExpression | BitVector) {\n        if (other instanceof BitVector) {\n            return new LogicalExpression(\n                andToDnf2(this.conjunctions, [other]),\n            );\n        }\n\n        if (this.isTriviallyFalse() || other.isTriviallyFalse()) {\n            return LogicalExpression.false();\n        }\n        return new LogicalExpression(\n            andToDnf2(this.conjunctions, other.conjunctions),\n        );\n    }\n\n    /**\n     * From each conjunction in the DNF, removes `drop` unless the\n     * `unless` bit is set.\n     */\n    drop_unless(drop: number, unless: number) {\n        return new LogicalExpression(\n            this.conjunctions.map((c) =>\n                c.test(unless) ? c : c.clone().clearBit(drop),\n            ),\n        );\n    }\n\n    /**\n     * Simplifies the expression by removing disjuncts that are implied by a another disjunct.\n     */\n    removeDuplicates() {\n        const terms: BitVector[] = [];\n        nextTerm: for (let i = 0; i < this.conjunctions.length; i++) {\n            const candidate = this.conjunctions[i];\n            const toRemove: number[] = [];\n            for (const [existingIdx, existing] of terms.entries()) {\n                if (existing.isSubsetOf(candidate)) {\n                    // existing requires fewer or equal things than candidate\n                    continue nextTerm;\n                } else if (candidate.isSubsetOf(existing)) {\n                    toRemove.push(existingIdx);\n                }\n            }\n\n            for (let j = toRemove.length - 1; j >= 0; j--) {\n                const idx = toRemove[j];\n                // remove element at idx without shifting the rest by\n                // swapping if needed\n                if (idx === terms.length - 1) {\n                    terms.pop()\n                } else {\n                    terms[idx] = terms.pop()!;\n                }\n            }\n            terms.push(candidate);\n        }\n        return new LogicalExpression(terms);\n    }\n\n    /**\n     * Computes .or, and returns true iff it resulted in\n     * the terms of `this` changing.\n     */\n    orExtended(other: LogicalExpression) {\n        const self: BitVector[] = [...this.conjunctions];\n        const filteredOther: BitVector[] = [];\n        let useful = false;\n\n        const otherTerms = other.conjunctions;\n        nextTerm: for (let i = 0; i < otherTerms.length; i++) {\n            const candidate = otherTerms[i];\n            for (let j = 0; j < self.length; j++) {\n                const existing = self[j];\n                if (existing.isSubsetOf(candidate)) {\n                    continue nextTerm;\n                }\n            }\n            \n            filteredOther.push(candidate);\n            useful = true;\n            \n        }\n        return [useful, new LogicalExpression([...self, ...filteredOther])] as const;\n    }\n\n    /**\n     * Evaluates the expression assuming the variables in `vec` are true.\n     */\n    eval(vec: BitVector) {\n        return this.conjunctions.some((c) => c.isSubsetOf(vec));\n    }\n\n    /**\n     * Whether the expression always definitely evaluates to false.\n     */\n    isTriviallyFalse() {\n        return this.conjunctions.length === 0;\n    }\n\n    /**\n     * Whether the expression always definitely evaluates to true.\n     */\n    isTriviallyTrue() {\n        return (\n            this.conjunctions.length > 0 &&\n            this.conjunctions.some((c) => c.isEmpty())\n        );\n    }\n\n    /**\n     * Returns a deep clone of this expression\n     */\n    clone() {\n        return new LogicalExpression(this.conjunctions.map((c) => c.clone()));\n    }\n}\n\n/**\n * An optimized (unrolled) version of `andToDnf` for AND-ing exactly two expressions.\n */\nfunction andToDnf2(left: BitVector[], right: BitVector[]): BitVector[] {\n    const newExpr = [];\n    for (const l of left) {\n        for (const r of right) {\n            newExpr.push(l.or(r));\n        }\n    }\n    return newExpr;\n}\n\nexport function andToDnf(arr: BitVector[][]): BitVector[] {\n    if (arr.length === 2) {\n        return andToDnf2(arr[0], arr[1]);\n    }\n    const newExpr = [];\n    for (const tuple of cartesianProduct(...arr)) {\n        const newVec = tuple.reduce(\n            (acc, val) => acc.or(val),\n            new BitVector(),\n        );\n        newExpr.push(newVec);\n    }\n    return newExpr;\n}\n\nfunction cartesianProduct<T>(...allEntries: T[][]): T[][] {\n    return allEntries.reduce<T[][]>(\n        (results, entries) =>\n            results\n                .map((result) => entries.map((entry) => result.concat([entry])))\n                .reduce((subResults, result) => subResults.concat(result), []),\n        [[]],\n    );\n}\n","import { LogicalExpression } from './LogicalExpression';\nimport { BitVector } from './BitVector';\n\n/**\n * Requirements are a partial logic that makes statements about the present bits\n * and no statements about absent bits.\n */\nexport type Requirements = Record<number, LogicalExpression>;\n/**\n * A BitLogic models a least fixed-point logic (LFP).\n * Since every LogicalExpression can only mention terms positively\n * (no negation, no quantifiers) this least fixed-point always exists.\n */\nexport type BitLogic = LogicalExpression[];\n\nexport function mergeRequirements(numBits: number, ...reqs: Requirements[]): BitLogic {\n    const requirements: LogicalExpression[] = [];\n    const mergedRequirements: Requirements = {};\n    Object.assign(mergedRequirements, ...reqs);\n    for (let i = 0; i < numBits; i++) {\n        requirements.push(mergedRequirements[i] ?? LogicalExpression.false());\n    }\n    return requirements;\n}\n\n\n/* \n * Returns the least fixed-point of the given requirements,\n * which can be interpreted as the logical result of the given requirements.\n * This is a BitVector from which no new facts can be derived.\n */\nexport function computeLeastFixedPoint(\n    /** Why is this being computed? For logging */\n    reason: string,\n    /** The BitLogic describing the logic program (requirements). */\n    logic: BitLogic,\n    /**\n     * To resume computation from an earlier result after adding facts to `additionalRequirements`\n     * (concretely: semilogic requirements), pass startingBits. Purely a performance optimization.\n     */\n    startingBits?: BitVector,\n) {\n    // This is an extremely simple iterate-to-fixpoint solver in O(n^2).\n    // There are better algorithms but this usually converges after\n    // about 15 rounds.\n    const bits = startingBits?.clone() ?? new BitVector();\n    let changed = true;\n    let iterations = 0;\n    const start = performance.now();\n    while (changed) {\n        changed = false;\n        for (const [idx, expr] of logic.entries()) {\n            const evaluate = (e: LogicalExpression) => {\n                const val = e.eval(bits);\n                if (val) {\n                    bits.setBit(idx);\n                    return true;\n                }\n                return false;\n            };\n\n            if (expr.isTriviallyFalse()) {\n                continue;\n            } else if (!bits.test(idx)) {\n                const didChange = evaluate(expr);\n                changed ||= didChange;\n            }\n        }\n        iterations++;\n    }\n    console.log(\n        reason,\n        'fixpoint iteration took',\n        performance.now() - start,\n        'ms for',\n        iterations,\n        'iterations',\n    );\n\n    return bits;\n}\n\nexport function removeDuplicates(logic: BitLogic) {\n    for (const [idx, expr] of logic.entries()) {\n        if (expr.conjunctions.length >= 2) {\n            logic[idx] = expr.removeDuplicates();\n        }\n    }\n}\n\n/**\n * Unifies non-opaque requirements if they directly imply each other. This is mostly\n * for simplifying clusters like the Sky, where there are lots of areas that are\n * all equally accessible as long as you're somewhere in the sky. This means one of\n * the unified areas will only have a single bit requirement, which can be inlined later.\n *\n * Returns true iff any simplifications have been made.\n */\nexport function unifyRequirements(\n    opaqueBits: BitVector,\n    requirements: LogicalExpression[],\n) {\n    // First, an O(n) scan to rule out expressions that are definitely not eligible\n    const unificationCandidates: number[][] = requirements.map(() => []);\n    for (const [idx, expr] of requirements.entries()) {\n        if (opaqueBits.test(idx)) {\n            continue;\n        }\n        for (const conj of expr.conjunctions) {\n            if (conj.numSetBits === 1) {\n                const bit = conj.getSingleSetBit();\n                if (bit === idx || opaqueBits.test(bit)) {\n                    continue;\n                }\n                (unificationCandidates[bit]).push(idx);\n            }\n        }\n    }\n\n    let simplified = false;\n    for (let a = 0; a < requirements.length; a++) {\n        const targetList = unificationCandidates[a];\n        for (const b of targetList) {\n            if (tryUnifyEquivalent(requirements, a, b)) {\n                simplified = true;\n            }\n        }\n    }\n\n    return simplified;\n}\n\n/**\n * Check if:\n *  z <= a\n *  a <= b | x\n *  b <= a | y\n * Rewrite to:\n *  z <= a\n *  a <= b,\n *  b <= x | y,\n * This breaks a cycle between `a` and `b`, and any dependencies on `a`\n * can be rewritten to depend on `b` in a later shallowSimplify call.\n */\nfunction tryUnifyEquivalent(requirements: LogicalExpression[], a: number, b: number) {\n    const implA = requirements[a];\n    const implB = requirements[b];\n\n    if (implA.conjunctions.length < 2 || implB.conjunctions.length < 2) {\n        return false;\n    }\n\n    const bImpliesAIndex = implA.conjunctions.findIndex(\n        (cA) => cA.numSetBits === 1 && cA.test(b),\n    );\n    if (bImpliesAIndex === -1) {\n        return false;\n    }\n\n    const aImpliesBIndex = implB.conjunctions.findIndex(\n        (cB) => cB.numSetBits === 1 && cB.test(a),\n    );\n    if (aImpliesBIndex === -1) {\n        return false;\n    }\n\n    // Copy reqs from a to b\n    const implACon = implA.conjunctions.slice();\n    const bReqVec = implACon.splice(bImpliesAIndex, 1);\n    for (const cn of implACon) {\n        requirements[b] = requirements[b].or(cn);\n    }\n    requirements[a] = new LogicalExpression(bReqVec);\n\n    return true;\n}\n\n/**\n * Shallow simplification \"inlines\" non-opaque requirements that themselves only consist\n * of at most one conjunction into upstream conjunctions. A DNF requirement with zero\n * conjunctions is always False, so any conjunctions it appears in can be dropped,\n * while a DNF with exactly one conjunction can be inlined.\n *\n * Returns true iff any simplifications could be made.\n * \n * \n * E.g:\n *   a <= b&c | f | d\n *   b <= <false>\n *   d <= e\n *   f <= g&h\n * Rewrite to:\n *   a <= g&h | e\n *   b <= <false>\n *   d <= e\n *   f <= g&h\n */\nexport function shallowSimplify(\n    opaqueBits: BitVector,\n    requirements: BitLogic,\n) {\n    const inliningCandidates = new BitVector();\n\n    let simplified = false;\n\n    for (let item = 0; item < requirements.length; item++) {\n        if (\n            !opaqueBits.test(item) &&\n            requirements[item].conjunctions.length <= 1\n        ) {\n            inliningCandidates.setBit(item);\n        }\n    }\n\n    for (const [idx, expr] of requirements.entries()) {\n        if (expr.conjunctions.length >= 30) {\n            continue;\n        }\n        let newExpr = LogicalExpression.false();\n        for (const conj of expr.conjunctions) {\n            if (conj.intersects(inliningCandidates)) {\n                simplified = true;\n                let newItems = new BitVector();\n                let skip = false;\n                for (const reqItem of conj.iter()) {\n                    if (!inliningCandidates.test(reqItem)) {\n                        newItems.setBit(reqItem);\n                    } else {\n                        const revealed = requirements[reqItem];\n\n                        if (revealed.isTriviallyTrue()) {\n                            continue;\n                        }\n\n                        if (revealed.isTriviallyFalse()) {\n                            skip = true;\n                            break;\n                        }\n                        newItems = newItems.or(revealed.conjunctions[0]);\n                    }\n                }\n                if (!skip && !newItems.test(idx)) {\n                    newExpr = newExpr.or(newItems);\n                }\n            } else {\n                newExpr = newExpr.or(conj);\n            }\n        }\n\n        requirements[idx] = newExpr;\n    }\n    return simplified;\n}\n\n/**\n * Bottom-up propagation propagates disjuncts that consist of completely\n * opaque bits until a fixpoint is reached.\n * \n * This is basically symbolic logical state computation - but instead\n * of computing boolean logical state bottom-up, we compute requirements\n * bottom-up, which a fixpoint being reached if requirements don't change anymore.\n * \n * Previously the use case was implemented using a top-down algorithm, but that\n * ended up with unpredictable performance due to heuristics. Bottom-up performs well\n * and computes all tooltips very quickly (<250ms on my machine, which is not\n * quite fast enough to move it to the main thread, but pretty hard to beat).\n * \n * The reason I investigated replacing the top-down algorithm with a bottom-\n * up algorithm is my hope that this approach will adapt better to alternative\n * or future logic implementations that don't map everything to bits, e.g. lepe's\n * Rust logic experiments that literally traverse an area graph. In that case\n * \"opaque bits\" are ::Item requirements, propagation happens through area exits,\n * ::Event requirements and ::Area requirements, and the keys in our lookup are Event\n * IDs and Area+ToD keys. A fixpoint is then reached if we can't find new paths to Areas\n * and Events, and after that we can inline them into the check requirements since\n * checks cannot be a further dependency. The main challenge will be having a\n * normalized requirements form that you can quickly use to identify whether there is\n * a satisfiable option and figure out if a fixpoint is reached, since\n * expression equality really wants a normal form.\n */\nexport function bottomUpTooltipPropagation(\n    opaqueBits: BitVector,\n    requirements: BitLogic,\n) {\n    // First, we split our requirements into disjuncts that contain non-opaque\n    // terms and disjuncts that contain no non-opaque terms.\n    const originalRequirements = requirements.map(\n        (expr) =>\n            new LogicalExpression(\n                expr.conjunctions.filter((c) => !c.isSubsetOf(opaqueBits)),\n            ),\n    );\n\n    const propagationCandidates = new BitVector();\n\n    for (const [idx, expr] of requirements.entries()) {\n        const newExpr = new LogicalExpression(\n            expr.conjunctions.filter((c) => c.isSubsetOf(opaqueBits)),\n        );\n        requirements[idx] = newExpr;\n        if (!newExpr.isTriviallyFalse() || opaqueBits.test(idx)) {\n            propagationCandidates.setBit(idx);\n        }\n    }\n\n    // Invariant: Terms in `requirements` contain no non-opaque bits\n    // Invariant: For every requirement in `requirements` that is opaque or\n    // isn't trivially false, `propagationCandidates` has the corresponding bit set.\n\n    let changed = true;\n    let rounds = 0;\n\n    let recentlyChanged: BitVector | undefined = undefined;\n\n\n    while (changed) {\n        rounds++;\n        changed = false;\n        const thisRoundChanged = new BitVector();\n\n        const interestingCandidates = recentlyChanged\n            ? recentlyChanged.and(propagationCandidates)\n            : propagationCandidates;\n\n        // Repeatedly apply the \"rules\" to further propagate\n        // requirements\n        for (const [idx, expr] of originalRequirements.entries()) {\n\n            // If something already requires Nothing, we don't even need to\n            // bother with alternative ways to fulfill this requirement\n            if (requirements[idx].isTriviallyTrue()) {\n                continue;\n            }\n\n            let additionalTerms = LogicalExpression.false();\n    \n            for (const conj of expr.conjunctions) {\n                // We can only propagate if all mentioned bits are either opaque or refer\n                // to an expression where we've found at least one way for it to be satisfied.\n                // If a non-opaque bit in there had no propagated requirements yet, `toPropagate`\n                // would end up being False and the whole thing would be pointless.\n                // Additionally, as an optimization, after the first round we only look at\n                // terms we updated last round, to reduce the number operations that definitely\n                // won't cause an update.\n                if (\n                    conj.isSubsetOf(propagationCandidates) &&\n                    conj.intersects(interestingCandidates)\n                ) {\n                    const newItems = new BitVector();\n                    let toPropagate = LogicalExpression.true();\n                    for (const reqBit of conj.iter()) {\n                        if (opaqueBits.test(reqBit)) {\n                            newItems.setBit(reqBit);\n                        } else {\n                            const revealed = requirements[reqBit];\n                            toPropagate = toPropagate\n                                .and(revealed)\n                                .removeDuplicates();\n                        }\n                    }\n\n                    // We record all propagated possibilities in additionalTerms, so that\n                    // below we can check if any of the additional terms are useful.\n                    for (const term of toPropagate.conjunctions) {\n                        additionalTerms = additionalTerms.or(term.or(newItems));\n                    }\n                }\n            }\n\n            const [useful, newExpr] = requirements[idx].orExtended(additionalTerms);\n            if (useful) {\n                thisRoundChanged.setBit(idx);\n                changed = true;\n                requirements[idx] = newExpr.removeDuplicates();\n                propagationCandidates.setBit(idx);\n            }\n        }\n\n        recentlyChanged = thisRoundChanged;\n    }\n\n\n    // We've reached a fixed point, which means we cannot find any new paths\n    // in our requirement graph. So our output requirements now contain all\n    // possible paths.\n\n    console.log('bottom-up tooltip requirements took', rounds, 'rounds');\n}\n","import _ from 'lodash';\n\nexport enum Op {\n    And = 'and',\n    Or = 'or',\n}\n\nexport type Item = BooleanExpression | string;\ntype BinOp<T> = (left: T, right: T) => boolean;\ntype ParentItems = {\n    [op in Op]: Item[]\n}\n\nexport type ReducerArg<T> = { isReduced: true, accumulator: T, item: T } | { isReduced: false, accumulator: T, item: string };\ntype Reducer<T> = (arg: ReducerArg<T>) => T;\ntype Reducers<T> = {\n    andInitialValue: T,\n    orInitialValue: T,\n    andReducer: Reducer<T>,\n    orReducer: Reducer<T>,\n}\n\nexport class BooleanExpression {\n    type: Op;\n    items: Item[];\n\n    constructor(items: Item[], type: Op) {\n        this.items = items;\n        this.type = type;\n    }\n\n    static and(...items: Item[]) {\n        return new BooleanExpression(items, Op.And);\n    }\n\n    static or(...items: Item[]) {\n        return new BooleanExpression(items, Op.Or);\n    }\n\n    isAnd() {\n        return this.type === Op.And;\n    }\n\n    isOr() {\n        return this.type === Op.Or;\n    }\n\n    reduce<T>({\n        andInitialValue,\n        andReducer,\n        orInitialValue,\n        orReducer,\n    }: Reducers<T>): T {\n        const reducerArguments = (accumulator: T, item: Item): ReducerArg<T> => {\n            if (BooleanExpression.isExpression(item)) {\n                const reducedItem = item.reduce({\n                    andInitialValue,\n                    andReducer,\n                    orInitialValue,\n                    orReducer,\n                });\n\n                return {\n                    accumulator,\n                    item: reducedItem,\n                    isReduced: true,\n                };\n            }\n            return {\n                accumulator,\n                item,\n                isReduced: false,\n            };\n        };\n\n        if (this.isAnd()) {\n            return _.reduce(\n                this.items,\n                (acc, item) => andReducer(\n                    reducerArguments(acc, item),\n                ),\n                andInitialValue,\n            );\n        }\n\n        if (this.isOr()) {\n            return _.reduce(\n                this.items,\n                (acc, item) => orReducer(\n                    reducerArguments(acc, item),\n                ),\n                orInitialValue,\n            );\n        }\n        throw Error(`Invalid type: ${this.type}`);\n    }\n\n    evaluate(isItemTrue: (item: string) => boolean) {\n        return this.reduce({\n            andInitialValue: true,\n            andReducer: ({ accumulator, item, isReduced }) => accumulator && (isReduced ? item : isItemTrue(item)),\n            orInitialValue: false,\n            orReducer: ({ accumulator, item, isReduced }) => accumulator || (isReduced ? item : isItemTrue(item)),\n        });\n    }\n\n    simplify(implies: BinOp<string>, iterations = 3) {\n        let updatedExpression = this.flatten();\n\n        for (let i = 0; i < iterations; i++) {\n            updatedExpression = updatedExpression.removeDuplicateChildren(implies);\n            updatedExpression = updatedExpression.removeDuplicateExpressions(implies);\n            updatedExpression = updatedExpression.shiftWeakerTermsUp(implies);\n        }\n\n        return updatedExpression;\n    }\n\n    oppositeType() {\n        if (this.isAnd()) {\n            return Op.Or;\n        }\n        if (this.isOr()) {\n            return Op.And;\n        }\n        throw Error(`Invalid type for boolean expression: ${this.type}`);\n    }\n\n    static isExpression(item: unknown): item is BooleanExpression {\n        return typeof item === 'object' && item instanceof BooleanExpression;\n    }\n\n    isEqualTo(otherExpression: Item, areItemsEqual: BinOp<string>): boolean {\n        if (!BooleanExpression.isExpression(otherExpression) || this.type !== otherExpression.type || this.items.length !== otherExpression.items.length) {\n            return false;\n        }\n\n        const difference = _.xorWith(this.items, otherExpression.items, (item, otherItem) => {\n            if (BooleanExpression.isExpression(item)) {\n                return item.isEqualTo(otherItem, areItemsEqual);\n            }\n            // if one item is not an expression and the other is not then they cannot be equal\n            if (BooleanExpression.isExpression(otherItem)) {\n                return false;\n            }\n            return areItemsEqual(item, otherItem);\n        });\n        return _.isEmpty(difference);\n    }\n\n    flatten(): BooleanExpression {\n        const newItems = this.items.flatMap((item) => {\n            if (!BooleanExpression.isExpression(item)) {\n                return item;\n            }\n            const flatItem = item.flatten();\n            if (_.isEmpty(flatItem.items)) {\n                return [];\n            }\n            if (flatItem.type === this.type || flatItem.items.length === 1) {\n                return flatItem.items;\n            }\n            return flatItem;\n        });\n\n        if (newItems.length === 1) {\n            const firstItem = _.first(newItems);\n            if (BooleanExpression.isExpression(firstItem)) {\n                return firstItem;\n            }\n        }\n\n        return new BooleanExpression(newItems, this.type);\n    }\n\n    static createFlatExpression(items: Item[], type: Op) {\n        return new BooleanExpression(items, type).flatten();\n    }\n\n    // determines if a provided item is subsumed by a provided collection of items\n    // calculation depends on the type of the containing expression\n    // implies is the function for determing if requirements are subsumable (defines the relationship between items)\n    static itemIsSubsumed(itemsCollection: Item[], item: string, expressionType: Op, implies: BinOp<string>) {\n        let itemIsSubsumed = false;\n        itemsCollection.forEach((otherItem) => {\n            if (this.isExpression(otherItem)) {\n                return true;\n            }\n\n            switch (expressionType) {\n                case Op.And: {\n                    // for and logic the subsuming item (the item from the collection) needs to imply the subsumed item\n                    // otherwise the logic would lose precision on counted items (i.e. Sword x2 could subsume Sword x3 depending on sequence)\n                    if (implies(otherItem, item)) {\n                        itemIsSubsumed = true;\n                        return false;\n                    }\n                    break;\n                }\n                case Op.Or: {\n                    // for an or expression this precision doesn't matter - Sword x2 is just as good as Sword x3, therefore any implying\n                    // item can subsume the item in question\n                    if (implies(item, otherItem)) {\n                        itemIsSubsumed = true;\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        });\n        return itemIsSubsumed;\n    }\n\n    getUpdatedParentItems(parentItems: ParentItems) {\n        return _.mergeWith({}, parentItems, { [this.type]: this.items }, (objectValue: Item[], sourceValue: Item[]) => {\n            if (_.isArray(objectValue)) {\n                return _.concat(objectValue, _.filter(sourceValue, (value) => !BooleanExpression.isExpression(value)));\n            }\n            return undefined;\n        });\n    }\n\n    removeDuplicateChildrenHelper(implies: BinOp<string>, parentItems: ParentItems) {\n        const newItems: Item[] = [];\n        const updatedParentItems = this.getUpdatedParentItems(parentItems);\n        const sameTypeItems = _.get(parentItems, this.type);\n        const oppositeTypeItems = _.get(parentItems, this.oppositeType());\n        let removeSelf = false;\n\n        this.items.forEach((item) => {\n            if (BooleanExpression.isExpression(item)) {\n                const {\n                    expression: childExpression,\n                    removeParent: childRemoveParent,\n                } = item.removeDuplicateChildrenHelper(implies, updatedParentItems);\n\n                if (childRemoveParent) {\n                    removeSelf = true;\n                    return false;\n                }\n                newItems.push(childExpression);\n            } else {\n                if (BooleanExpression.itemIsSubsumed(oppositeTypeItems, item, this.oppositeType(), implies)) {\n                    removeSelf = true;\n                    return false;\n                }\n\n                if (!BooleanExpression.itemIsSubsumed(sameTypeItems, item, this.type, implies)) {\n                    newItems.push(item);\n                }\n            }\n            return true;\n        });\n\n        if (removeSelf) {\n            return {\n                expression: BooleanExpression.and(),\n                removeParent: false,\n            };\n        }\n\n        const expression = BooleanExpression.createFlatExpression(newItems, this.type);\n        if (_.isEmpty(expression.items)) {\n            return {\n                expression: BooleanExpression.and(),\n                removeParent: true,\n            };\n        }\n\n        return {\n            expression,\n            removeParent: false,\n        };\n    }\n\n    removeDuplicateChildren(implies: BinOp<string>) {\n        const { expression } = this.removeDuplicateChildrenHelper(implies, {\n            [Op.And]: [],\n            [Op.Or]: [],\n        });\n        return expression;\n    }\n\n    isSubsumedBy(otherExpression: BooleanExpression, implies: BinOp<string>, removeIfIdentical: boolean, expressionType: Op): boolean {\n        if (this.isEqualTo(otherExpression, (item, otherItem) => implies(item, otherItem) && implies(otherItem, item))) {\n            return removeIfIdentical;\n        }\n        return otherExpression.items.every((otherItem) => {\n            if (BooleanExpression.isExpression(otherItem)) {\n                return this.isSubsumedBy(otherItem, implies, true, expressionType);\n            }\n            return BooleanExpression.itemIsSubsumed(this.items, otherItem, expressionType, implies);\n        });\n    }\n\n    expressionIsSubsumed(expression: BooleanExpression, index: number, implies: BinOp<string>) {\n        let expressionIsSubsumed = false;\n        this.items.forEach((otherItem, otherIndex) => {\n            if (otherIndex === index) {\n                return true;\n            }\n\n            let otherExpression: BooleanExpression;\n            if (BooleanExpression.isExpression(otherItem)) {\n                otherExpression = otherItem;\n            } else {\n                otherExpression = BooleanExpression.and(otherItem);\n            }\n\n            const isSubsumed = expression.isSubsumedBy(otherExpression, implies, otherIndex < index, this.oppositeType());\n            if (isSubsumed) {\n                expressionIsSubsumed = true;\n                return false;\n            }\n            return true;\n        });\n        return expressionIsSubsumed;\n    }\n\n    removeDuplicateExpressionsInChildren(implies: BinOp<string>): BooleanExpression {\n        const newItems = this.items.map((item) => {\n            if (BooleanExpression.isExpression(item)) {\n                return item.removeDuplicateExpressions(implies);\n            }\n            return item;\n        });\n        return BooleanExpression.createFlatExpression(newItems, this.type);\n    }\n\n    removeDuplicateExpressions(implies: BinOp<string>): BooleanExpression {\n        const parentExpression = this.removeDuplicateExpressionsInChildren(implies);\n        const newItems = parentExpression.items.filter((item, index) => {\n            let expression;\n            if (BooleanExpression.isExpression(item)) {\n                expression = item;\n            } else {\n                expression = BooleanExpression.and(item);\n            }\n\n            return !parentExpression.expressionIsSubsumed(expression, index, implies);\n        });\n\n        if (this.type === Op.Or && newItems.length >= 2 && _.every(_.map(newItems, BooleanExpression.isExpression))) {\n            const commonFactors: Item[] = [];\n            const booleanItems = newItems as BooleanExpression[];\n            _.forEach(booleanItems[0].items, (item) => {\n                if (_.every(_.map(booleanItems, (expr) => _.includes(expr.items, item)))) {\n                    commonFactors.push(item);\n                }\n            });\n            if (commonFactors.length) {\n                return new BooleanExpression([...commonFactors, new BooleanExpression([...(newItems.filter((item) => !commonFactors.includes(item)))], this.type)], this.oppositeType());\n            }\n        }\n        return BooleanExpression.createFlatExpression(newItems, this.type);\n    }\n\n    shiftWeakerTermsUp(implies: BinOp<string>): BooleanExpression {\n        const parentExpression = this.removeDuplicateExpressionsInChildren(implies);\n        if (parentExpression.isOr() && parentExpression.items.every((i) => !BooleanExpression.isExpression(i) || i.isAnd())) {\n            for (const item of parentExpression.items) {\n                if (!BooleanExpression.isExpression(item)) {\n                    continue;\n                }\n                for (const subItem of item.items) {\n                    if (BooleanExpression.isExpression(subItem) && parentExpression.items.every((otherItem, index) => (otherItem as BooleanExpression).expressionIsSubsumed(subItem, index, implies))) {\n                        console.log('blub')\n                        return BooleanExpression.and(subItem, BooleanExpression.or(...parentExpression.items, ));\n                    }\n                }\n            }\n        }\n\n        return parentExpression;\n    }\n}\n\nexport default BooleanExpression;\n","import {\n    bottomUpTooltipPropagation,\n    removeDuplicates,\n    shallowSimplify,\n    unifyRequirements,\n} from '../../logic/bitlogic/BitLogic';\nimport { BitVector } from '../../logic/bitlogic/BitVector';\nimport { LogicalExpression } from '../../logic/bitlogic/LogicalExpression';\nimport {\n    deserializeLogicalExpression,\n    serializeBooleanExpression,\n} from './Utils';\nimport { LeanLogic, WorkerRequest, WorkerResponse } from './Types';\nimport BooleanExpression from '../../logic/booleanlogic/BooleanExpression';\nimport { dnfToRequirementExpr } from './Algorithms';\n\n/**\n * This module contains various strategies to turn the requirements into a more compact and readable\n * form, with the goal of creating readable and understandable requirements for tooltips.\n */\n\n/**\n * Global application state. Will be initialized with the first message.\n */\ninterface GlobalState {\n    logic: LeanLogic;\n    opaqueBits: BitVector;\n    learned: Set<number>;\n    requirementsForBottomUp: LogicalExpression[];\n}\n\nlet g: GlobalState;\n\nconsole.log('Hello from worker!');\n\nonmessage = (ev: MessageEvent<WorkerRequest>) => {\n    const start = performance.now();\n    switch (ev.data.type) {\n        case 'initialize': {\n            const opaqueBits = new BitVector();\n            for (const bit of ev.data.opaqueBits) {\n                opaqueBits.setBit(bit);\n            }\n            const requirements = ev.data.requirements.map(\n                deserializeLogicalExpression,\n            );\n            g = {\n                logic: ev.data.logic,\n                opaqueBits,\n                learned: new Set(),\n                requirementsForBottomUp: requirements,\n            };\n\n            do {\n                // First, perform some cheap optimizations that will help every\n                // query afterwards.\n                removeDuplicates(g.requirementsForBottomUp);\n                while (shallowSimplify(g.opaqueBits, g.requirementsForBottomUp)) {\n                    removeDuplicates(g.requirementsForBottomUp);\n                }\n            } while (unifyRequirements(g.opaqueBits, g.requirementsForBottomUp));\n            console.log('worker', 'initializing and pre-simplifying took', performance.now() - start, 'ms');\n\n            const start2 = performance.now();\n            bottomUpTooltipPropagation(g.opaqueBits, g.requirementsForBottomUp);\n            console.log('worker', 'fixpoint propagation took', performance.now() - start2, 'ms');\n\n            break;\n        }\n        case 'analyze': {\n            if (!g) {\n                throw new Error('needs to be initialized first!!!!');\n            }\n            const expr = analyze(ev.data.checkId);\n            console.log('worker', 'total time for', ev.data.checkId, 'was', performance.now() - start, 'ms');\n            postMessage({\n                checkId: ev.data.checkId,\n                expression: serializeBooleanExpression(expr),\n            } satisfies WorkerResponse);\n        }\n    }\n};\n\nfunction analyze(checkId: string): BooleanExpression {\n    const bit = g.logic.itemBits[checkId];\n    const bottomUpExpression = g.requirementsForBottomUp[bit].removeDuplicates();\n    const simplifyStart = performance.now();\n    const simplified = dnfToRequirementExpr(g.logic, bottomUpExpression.conjunctions);\n    console.log('  ', 'worker', 'simplifying took', performance.now() - simplifyStart, 'ms');\n    return simplified;\n}\n","import { BitVector } from '../../logic/bitlogic/BitVector';\nimport { LogicalExpression } from '../../logic/bitlogic/LogicalExpression';\nimport BooleanExpression, {\n    Item,\n    Op,\n} from '../../logic/booleanlogic/BooleanExpression';\nimport { SerializedBooleanExpression, SerializedItem } from './Types';\n\nexport function deserializeLogicalExpression(\n    expr: number[][],\n): LogicalExpression {\n    const terms = [];\n    for (const conj of expr) {\n        const vec = new BitVector();\n        for (const bit of conj) {\n            vec.setBit(bit);\n        }\n        terms.push(vec);\n    }\n    return new LogicalExpression(terms);\n}\n\nexport function serializeLogicalExpression(\n    expr: LogicalExpression,\n): number[][] {\n    return expr.conjunctions.map((c) => [...c.iter()]);\n}\n\nexport function serializeBooleanExpression(\n    expr: BooleanExpression,\n): SerializedBooleanExpression {\n    return serializeBooleanItem(expr) as SerializedBooleanExpression;\n}\n\nfunction serializeBooleanItem(item: Item): SerializedItem {\n    if (BooleanExpression.isExpression(item)) {\n        switch (item.type) {\n            case Op.And:\n                return {\n                    type: 'and',\n                    items: item.items.map(serializeBooleanItem),\n                };\n            case Op.Or:\n                return {\n                    type: 'or',\n                    items: item.items.map(serializeBooleanItem),\n                };\n        }\n    } else {\n        return item;\n    }\n}\n\nexport function deserializeBooleanExpression(\n    expr: SerializedBooleanExpression,\n): BooleanExpression {\n    return new BooleanExpression(\n        expr.items.map((i) =>\n            typeof i === 'string' ? i : deserializeBooleanExpression(i),\n        ),\n        expr.type === 'and' ? Op.And : Op.Or,\n    );\n}\n","import _ from 'lodash';\nimport { BitVector } from '../../logic/bitlogic/BitVector';\nimport { LogicalExpression } from '../../logic/bitlogic/LogicalExpression';\nimport BooleanExpression, {\n    Item,\n} from '../../logic/booleanlogic/BooleanExpression';\nimport { LeanLogic } from './Types';\n\nfunction simplifier(logic: LeanLogic) {\n    return (a: string, b: string) => {\n        return a === b || Boolean(logic.impliedBy[b]?.includes(a));\n    };\n}\n\n/**\n * Converts a DNF to a readable requirements expression.\n *\n * Our DNF is a sum of products (SOP) with no negations and no don't-cares.\n * As a result, standard two-level simplification algorithms (Quine-McCluskey/Karnaugh Maps)\n * will not produce any simplifications.\n *\n * Instead, we are doing multi-level simplification as described in:\n * https://faculty.sist.shanghaitech.edu.cn/faculty/zhoupq/Teaching/Spr16/07-Multi-Level-Logic-Synthesis.pdf\n * https://www2.eecs.berkeley.edu/Pubs/TechRpts/1989/ERL-89-49.pdf (pp. 41-70)\n * We first remove all factors, and then treat the rest SOP as an algebraic expression.\n * Algebraic expressions don't know about special boolean rules (like a && !a = 0, a || !a = 1)\n * but since we don't have any don't cares and negations they will never be relevant.\n */\nexport function dnfToRequirementExpr(\n    logic: LeanLogic,\n    sop: BitVector[],\n): BooleanExpression {\n    if (sop.length === 0) {\n        return BooleanExpression.or();\n    }\n\n    if (sop.length === 1 && sop[0].isEmpty()) {\n        return BooleanExpression.and();\n    }\n\n    /*\n    return BooleanExpression.or(\n        ...sop.map((s) =>\n            BooleanExpression.and(\n                ...[...s.iter()].map((bit) => logic.allItems[bit]),\n            ),\n        ),\n    );\n    */\n\n    if (sop.length === 1) {\n        return BooleanExpression.and(\n            ...[...sop[0].iter()].map((x) => logic.allItems[x]),\n        ).simplify(simplifier(logic));\n    }\n\n    const conjunctions = new LogicalExpression(sop).removeDuplicates()\n        .conjunctions;\n\n    // After removing duplicates, remove dominated stuff from our terms so that\n    // simplification doesn't get funny ideas like pulling out irrelevant terms\n    // that we later can't easily simplify in a multi level form.\n    for (const conj of conjunctions) {\n        for (const bit of [...conj.iter()]) {\n            for (const dominator of logic.impliedBy[logic.allItems[bit]] ??\n                []) {\n                const dominatorBit = logic.itemBits[dominator];\n                if (dominatorBit !== bit && conj.test(dominatorBit)) {\n                    conj.clearBit(bit);\n                }\n            }\n        }\n    }\n\n    // First, remove all common factors and from our SOP so that it's \"cube-free\".\n    // This is a requirement for the algorithm to work, as per the presentation.\n    let commonFactors = new Set<number>(conjunctions[0].iter());\n    for (const conj of conjunctions) {\n        commonFactors = new Set(\n            // eslint-disable-next-line no-loop-func\n            [...conj.iter()].filter((b) => commonFactors.has(b)),\n        );\n    }\n\n    // Build a list of all variables mentioned in this expression.\n    const variables = new Set<number>();\n\n    for (const conj of conjunctions) {\n        for (const bit of commonFactors) {\n            conj.clearBit(bit);\n        }\n        for (const bit of conj.iter()) {\n            variables.add(bit);\n        }\n    }\n\n    // At this point it's best to just consult the lecture presentation for why this is happening.\n    const kernels = findKernels(\n        conjunctions,\n        [...variables],\n        new BitVector(),\n    ).filter((k) => !k.coKernel.isEmpty());\n\n    // Columns are all unique cubes in all kernels\n    const columns = kernels.reduce<BitVector[]>((acc, kernel) => {\n        for (const kCube of kernel.kernel) {\n            if (!acc.some((cube) => kCube.equals(cube))) {\n                acc.push(kCube);\n            }\n        }\n        return acc;\n    }, []);\n\n    // Rows are labelled with all unique co-kernels.\n    const rows = kernels;\n\n    if (rows.length > 0 && columns.length > 0) {\n        // Create a matrix with ones in places where column cube appears in row kernel.\n        const matrix = Array<(0 | 1)[]>(rows.length)\n            .fill([])\n            .map(() => Array<0 | 1>(columns.length).fill(0));\n        for (const [col, kernelCube] of columns.entries()) {\n            for (const [row, coKernel] of rows.entries()) {\n                if (coKernel.kernel.some((kCube) => kCube.equals(kernelCube))) {\n                    matrix[row][col] = 1;\n                }\n            }\n        }\n\n        // Again look at the lecture presentation here.\n        const rowWeight = (row: number) => rows[row].coKernel.numSetBits + 1;\n        const colWeight = (col: number) => columns[col].numSetBits;\n        const value = (col: number, row: number) =>\n            rows[row].coKernel.or(columns[col]).numSetBits;\n\n        const literalsSaved = (rectRows: number[], rectCols: number[]) =>\n            _.sumBy(rectRows, (row) =>\n                _.sumBy(rectCols, (col) =>\n                    matrix[row][col] ? value(col, row) : 0,\n                ),\n            ) -\n            _.sumBy(rectRows, rowWeight) -\n            _.sumBy(rectCols, colWeight);\n\n        // This is the thesis algorithm for enumerating all prime rectangles.\n        // Theoretically the algorithm is branch-and-bound, but our problems\n        // are small enough for branch to be enough.\n        const allRects: [number[], number[]][] = [];\n        genRectangles(\n            rows.map((_val, idx) => idx),\n            columns.map((_val, idx) => idx),\n            matrix,\n            (rows, cols) => {\n                allRects.push([rows, cols]);\n                // No bound.\n                return true;\n            },\n        );\n\n        if (allRects.length) {\n            const [, rectCols] = _.maxBy(allRects, ([rows, cols]) =>\n                literalsSaved(rows, cols),\n            )!;\n\n            const divisor = rectCols.map((col) => columns[col]);\n            // console.log('would extract:', divisor.map((val) => [...val.iter()].map((bit) => logic.allItems[bit]).join('&')).join(' + '));\n            // console.log('original expression:', conjunctions.map((val) => [...val.iter()].map((bit) => logic.allItems[bit]).join('&')).join(' + '));\n            // const divTimer = performance.now();\n            const { quotient, remainder } = algebraicDivision(\n                conjunctions,\n                divisor,\n            );\n            // console.log(`algebraic division took`, performance.now() - divTimer, 'ms');\n\n            // Recursively simplify the quotient, divisor and remainder (divisor probably doesn't need to be...)\n\n            const optQuotient = new LogicalExpression(\n                quotient,\n            ).removeDuplicates();\n            const andTerms: Item[] = [...commonFactors].map(\n                (f) => logic.allItems[f],\n            );\n            const product = BooleanExpression.and(\n                dnfToRequirementExpr(logic, optQuotient.conjunctions),\n                dnfToRequirementExpr(logic, divisor),\n            );\n            const sum = BooleanExpression.or(\n                product,\n                dnfToRequirementExpr(logic, remainder),\n            );\n\n            // CommonFactor1 and CommonFactor2 and (Quotient and Divisor or Remainder)\n            return BooleanExpression.and(...andTerms, sum).simplify(\n                simplifier(logic),\n            );\n        }\n    }\n\n    // CommonFactor1 and CommonFactor2 and (SOPWithoutCommonFactors)\n    return BooleanExpression.and(\n        ...[...commonFactors].map((i) => logic.allItems[i]),\n        BooleanExpression.or(\n            ...conjunctions.map((c) => bitVecToRequirements(logic, c)),\n        ),\n    ).simplify(simplifier(logic));\n}\n\nfunction genRectangles(\n    allRows: number[],\n    allCols: number[],\n    matrix: (0 | 1)[][],\n    callback: (rows: number[], cols: number[]) => boolean,\n) {\n    // Trivial rectangles are rectangles of height 1 or width 1.\n    // A trivial row rectangle is *prime* if no other row\n    // has ones everywhere we have ones. Expressed differently:\n    // We're prime if there is no such other row that for every column,\n    // \"our row has a 1\" implies \"other row has a 1\" (and by A=>B <=> Bv!A)\n    for (const row of allRows) {\n        const ones = allCols.filter((col) => matrix[row][col]);\n        if (\n            ones.length &&\n            !allRows.some(\n                (otherRow) =>\n                    otherRow !== row &&\n                    allCols.every(\n                        (otherCol) =>\n                            !ones.includes(otherCol) ||\n                            matrix[otherRow][otherCol],\n                    ),\n            )\n        ) {\n            callback([row], ones);\n        }\n    }\n\n    for (const col of allCols) {\n        const ones = allRows.filter((row) => matrix[row][col]);\n        if (\n            ones.length &&\n            !allCols.some(\n                (otherCol) =>\n                    otherCol !== col &&\n                    allRows.every(\n                        (otherRow) =>\n                            !ones.includes(otherRow) ||\n                            matrix[otherRow][otherCol],\n                    ),\n            )\n        ) {\n            callback(ones, [col]);\n        }\n    }\n    genRectanglesRecursive(allRows, allCols, matrix, 0, [], [], callback);\n}\n\nfunction genRectanglesRecursive(\n    allRows: number[],\n    allCols: number[],\n    matrix: (0 | 1)[][],\n    index: number,\n    // The paper doesn't use this?\n    _rectRows: number[],\n    rectCols: number[],\n    callback: (rows: number[], cols: number[]) => boolean,\n) {\n    for (const c of allCols) {\n        if (c >= index && allRows.filter((row) => matrix[row][c]).length >= 2) {\n            // create M1 with rows 0 where c is 0 and rows intact where c is 1\n            const m1 = matrix.map((row, rowIndex) =>\n                matrix[rowIndex][c] ? row.slice() : row.map(() => 0 as const),\n            );\n            const rect1Rows = allRows.filter((row) => matrix[row][c]);\n            const rect1Cols = rectCols.slice();\n\n            let prune = false;\n            for (const c1 of allCols) {\n                if (\n                    allRows.filter((row) => m1[row][c1]).length ===\n                    allRows.filter((row) => matrix[row][c]).length\n                ) {\n                    if (c1 < c) {\n                        prune = true;\n                        break;\n                    } else {\n                        rect1Cols.push(c1);\n                        for (const row of allRows) {\n                            m1[row][c1] = 0;\n                        }\n                    }\n                }\n            }\n\n            if (!prune) {\n                const bound = callback(rect1Rows, rect1Cols);\n                if (!bound) {\n                    genRectanglesRecursive(\n                        allRows,\n                        allCols,\n                        m1,\n                        c,\n                        rect1Rows,\n                        rect1Cols,\n                        callback,\n                    );\n                }\n            }\n        }\n    }\n}\n\nfunction findKernels(\n    cubes: BitVector[],\n    variables: number[],\n    coKernelPath: BitVector,\n    seenCoKernels: BitVector[] = [],\n    minIdx = 0,\n): { kernel: BitVector[]; coKernel: BitVector }[] {\n    const kernels = [];\n    for (const [idx, bit] of variables.entries()) {\n        if (idx < minIdx) {\n            continue;\n        }\n        const s = cubes.filter((c) => c.test(bit));\n        if (s.length >= 2) {\n            const co = s.reduce((acc, c) => acc.and(c), s[0]);\n            const subPath = coKernelPath.or(co);\n            const quot = algebraicDivision(cubes, [co]).quotient;\n            const subKernels = findKernels(\n                quot,\n                variables,\n                subPath,\n                seenCoKernels,\n                idx + 1,\n            );\n            for (const sub of subKernels) {\n                if (\n                    !seenCoKernels.some((seenCo) => seenCo.equals(sub.coKernel))\n                ) {\n                    seenCoKernels.push(sub.coKernel);\n                    kernels.push(sub);\n                }\n            }\n        }\n    }\n\n    if (!seenCoKernels.some((seenCo) => seenCo.equals(coKernelPath))) {\n        kernels.push({\n            kernel: cubes,\n            coKernel: coKernelPath.clone(),\n        });\n    }\n\n    return kernels;\n}\n\nfunction algebraicDivision(\n    expr: BitVector[],\n    divisor: BitVector[],\n): { quotient: BitVector[]; remainder: BitVector[] } {\n    let quotient: BitVector[] | undefined;\n    for (const divCube of divisor) {\n        const c = expr\n            .filter((c) => divCube.isSubsetOf(c))\n            .map((c) => c.clone());\n        if (c.length === 0) {\n            return { quotient: [], remainder: expr };\n        }\n        for (const ci of c) {\n            for (const bit of divCube.iter()) {\n                ci.clearBit(bit);\n            }\n        }\n        if (!quotient) {\n            quotient = c;\n        } else {\n            quotient = quotient.filter((qc) => c.some((cc) => cc.equals(qc)));\n        }\n    }\n\n    const qd = new LogicalExpression(quotient!)\n        .and(new LogicalExpression(divisor))\n        .removeDuplicates();\n    const remainder = expr.filter(\n        (e) => !qd.conjunctions.some((qd) => qd.isSubsetOf(e)),\n    );\n    return { quotient: quotient!, remainder };\n}\n\nfunction bitVecToRequirements(\n    logic: LeanLogic,\n    vec: BitVector,\n): BooleanExpression {\n    return BooleanExpression.and(\n        ...[...vec.iter()].map((x) => logic.allItems[x]),\n    );\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [361], function() { return __webpack_require__(7451); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"2ad77e15\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/SS-Randomizer-Tracker/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t451: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkss_randomizer_tracker\"] = self[\"webpackChunkss_randomizer_tracker\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(361).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["ONE","BigInt","ZERO","BitVector","bits","intSet","data","this","Set","bit","add","has","delete","other","a","b","size","tmp","filter","v","intersection","numSetBits","domainSize","str","Boolean","values","next","value","LogicalExpression","conjs","conjunctions","andToDnf2","isTriviallyFalse","false","drop","unless","map","c","test","clone","clearBit","terms","nextTerm","i","length","candidate","toRemove","entries","existingIdx","existing","isSubsetOf","push","j","idx","pop","self","filteredOther","useful","otherTerms","vec","some","isEmpty","left","right","newExpr","l","r","or","removeDuplicates","logic","expr","unifyRequirements","opaqueBits","requirements","unificationCandidates","conj","getSingleSetBit","simplified","targetList","tryUnifyEquivalent","implA","implB","bImpliesAIndex","findIndex","cA","cB","implACon","slice","bReqVec","splice","cn","shallowSimplify","inliningCandidates","item","setBit","intersects","newItems","skip","iter","reqItem","revealed","isTriviallyTrue","Op","g","BooleanExpression","items","type","And","Or","andInitialValue","andReducer","orInitialValue","orReducer","reducerArguments","accumulator","isExpression","reduce","isReduced","isAnd","_","acc","isOr","Error","isItemTrue","implies","iterations","updatedExpression","flatten","removeDuplicateChildren","removeDuplicateExpressions","shiftWeakerTermsUp","otherExpression","areItemsEqual","difference","otherItem","isEqualTo","flatMap","flatItem","firstItem","parentItems","objectValue","sourceValue","updatedParentItems","getUpdatedParentItems","sameTypeItems","oppositeTypeItems","oppositeType","removeSelf","forEach","removeDuplicateChildrenHelper","childExpression","expression","removeParent","itemIsSubsumed","and","createFlatExpression","removeIfIdentical","expressionType","every","isSubsumedBy","index","expressionIsSubsumed","otherIndex","parentExpression","removeDuplicateExpressionsInChildren","commonFactors","booleanItems","includes","subItem","console","log","itemsCollection","deserializeLogicalExpression","serializeBooleanExpression","serializeBooleanItem","simplifier","impliedBy","dnfToRequirementExpr","sop","x","allItems","simplify","dominator","dominatorBit","itemBits","variables","kernels","findKernels","k","coKernel","columns","kernel","kCube","cube","equals","rows","matrix","Array","fill","col","kernelCube","row","rowWeight","colWeight","literalsSaved","rectRows","rectCols","allRects","allRows","allCols","callback","ones","otherRow","otherCol","genRectanglesRecursive","genRectangles","_val","cols","divisor","algebraicDivision","quotient","remainder","optQuotient","andTerms","f","product","sum","bitVecToRequirements","_rectRows","m1","rowIndex","rect1Rows","rect1Cols","prune","c1","cubes","coKernelPath","seenCoKernels","minIdx","s","co","subPath","subKernels","sub","seenCo","divCube","ci","qc","cc","qd","e","onmessage","ev","start","performance","now","learned","requirementsForBottomUp","start2","originalRequirements","propagationCandidates","changed","rounds","recentlyChanged","undefined","thisRoundChanged","interestingCandidates","additionalTerms","toPropagate","reqBit","term","orExtended","bottomUpTooltipPropagation","checkId","bottomUpExpression","simplifyStart","analyze","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","id","loaded","__webpack_modules__","call","m","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","Object","keys","key","n","getter","__esModule","d","definition","o","defineProperty","enumerable","get","chunkId","Promise","all","promises","u","miniCssF","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","nmd","paths","children","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","then"],"sourceRoot":""}